# -*- coding: utf-8 -*-
"""project.ml.aie314_315

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_ES8-ger0zCkRwDSoDHuOeOENU0ftvSe
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.tree import plot_tree
from imblearn.over_sampling import SMOTE


# Load and prepare the data
file_path = 'forest_health_data.csv'  # Update with the path to your data file
data = pd.read_csv(file_path)

# ข้อมูลพื้นฐาน
data_info = pd.DataFrame(data.dtypes, columns=['Data Type'])
data_info['Non-Null Count'] = data.count()
display(data_info.style)

# ค่าต่าง ๆ ของข้อมูล
data_description = data.describe()
display(data_description.style)

# แสดงคอลัมก์ Health_Status

print(data['Health_Status'])

# Encode the target labels if necessary
le = LabelEncoder()
data['Health_Status'] = le.fit_transform(data['Health_Status'])  # Convert target variable to numerical values

# Print the mapping of encoded labels
print("Encoded Labels:")
for i, label in enumerate(le.classes_):
    print(f"{label}: {i}")

# Scale the features
scaler = StandardScaler()
scaled_features = scaler.fit_transform(data.drop(columns=['Plot_ID', 'Latitude', 'Longitude', 'Health_Status']))
data_scaled = pd.DataFrame(scaled_features, columns=data.drop(columns=['Plot_ID', 'Latitude', 'Longitude', 'Health_Status']).columns)
data_scaled['Health_Status'] = data['Health_Status']

# Split data into train and test sets
X = data_scaled.drop(columns=['Health_Status'])
y = data_scaled['Health_Status']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Apply SMOTE to handle class imbalance
smote = SMOTE(random_state=42)
X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)

"""สรุป:

การใช้ random_state=42 ใน SMOTE มีจุดประสงค์เพื่อให้ผลลัพธ์สามารถทำซ้ำได้ และเป็นค่าที่นิยมใช้ในวงการ data science แม้ว่าจะไม่มีเหตุผลพิเศษในการเลือก 42 ก็ตาม
"""

# Train the model
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train_resampled, y_train_resampled)
print("Number of trees in the forest:", len(model.estimators_))

"""สรุป:

การใช้ n_estimators=100 ใน Random Forest เป็นการกำหนดจำนวนต้นไม้ในแบบจำลอง โดย 100 เป็นค่าที่เหมาะสมในหลายๆ กรณี เนื่องจากให้ประสิทธิภาพที่ดีโดยไม่ใช้เวลาในการคำนวณนานเกินไป และช่วยลด overfitting
"""

# Predict and evaluate
y_pred = model.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy:.2f}')

# Calculate and print precision, recall, and F1-score
from sklearn.metrics import precision_score, recall_score, f1_score

precision = precision_score(y_test, y_pred, average='weighted', zero_division=1)
recall = recall_score(y_test, y_pred, average='weighted', zero_division=1)
f1 = f1_score(y_test, y_pred, average='weighted', zero_division=1)


print(f'Precision: {precision:.2f}')
print(f'Recall: {recall:.2f}')
print(f'F1-score: {f1:.2f}')

# Generate the Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
class_names = le.inverse_transform([0, 1, 2])  # Decode the classes

# Plot the Confusion Matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.title('Confusion Matrix of Health Status Prediction')
plt.show()

# เลือกแสดง Decision Tree ต้นที่หนึ่งในโมเดล Random Forest
plt.figure(figsize=(20, 10))  # กำหนดขนาดของแผนภาพ
plot_tree(model.estimators_[0], feature_names=X.columns, class_names=le.classes_, filled=True, rounded=True)
plt.title("Decision Tree from Random Forest")
plt.show()

import pandas as pd
# ... (rest of your code)

# Assuming 'data' is your DataFrame and you've already preprocessed it

# Select the first row for prediction
first_row = X_test.iloc[[0]]  # Select the first row as a DataFrame

# Make a prediction for the first row
first_row_prediction = model.predict(first_row)

# Decode the predicted label back to its original value (if needed)
predicted_health_status = le.inverse_transform(first_row_prediction)[0]

print(f"Predicted health status for the first row: {predicted_health_status}")